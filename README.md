## Lab 2

`.S` file is used when you want assembly that interact with C headers or marcos. It is preprocessed by C preprocessor before passed to assembler.

When compiile with `gcc`, it recognnizes this convention:
- For `.c`: Run the C compiler
- For `.S`: Run the C prepocessor, then the assembler (GAS)
- For `.s`: Run the Assembler

In `user/usys.S`
``` asm
#define SYSCALL(name) \
.globl name;    \
name: \
    mov $SYS_ ##name, %eax \
    int $T_SYSCALL \
    ret

SYSCALL(fork)
SYSCALL(exit)
SYSCALL(wait)

```
So the above code, after preprocessed, becomes..

``` asm

.globl fork
fork:
    mov $SYS_fork, %eax
    int $T_SYSCALL
    ret

.globl exit
exit:
    mov $SYS_exit, %eax
    int $T_SYSCALL
    ret

.globl wait
wait:
    mov $SYS_wait, %eax
    int $T_SYSCALL
    ret

```


The System Call Mechanism is very Clever. Its interrupt number is `64`. Remember when the CPU is interrupted, it looks for the interrupt handlers using the `Interrupt Descriptor Table (IDT)`. `tvinit()` in `trap.c` show the initialization of the IDT:

```C
void
tvinit(void)
{
  int i;

  for(i = 0; i < 256; i++)
    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);

  initlock(&tickslock, "time");
}
```

For SYSCALL, it is a **USER-LEVEL** Interrupt and also is a trap gate instead of an interrupt gate. Below is the a detail of the `SETGATE` function and also gate descriptor in each IDT entry.


```C
// Gate descriptors for interrupts and traps
struct gatedesc {
  uint off_15_0 : 16;   // low 16 bits of offset in segment
  uint cs : 16;         // code segment selector
  uint args : 5;        // # args, 0 for interrupt/trap gates
  uint rsv1 : 3;        // reserved(should be zero I guess)
  uint type : 4;        // type(STS_{TG,IG32,TG32})
  uint s : 1;           // must be 0 (system)
  uint dpl : 2;         // descriptor(meaning new) privilege level
  uint p : 1;           // Present
  uint off_31_16 : 16;  // high bits of offset in segment
};

// Set up a normal interrupt/trap gate descriptor.
// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.
//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone
// - sel: Code segment selector for interrupt/trap handler
// - off: Offset in code segment for interrupt/trap handler
// - dpl: Descriptor Privilege Level -
//        the privilege level required for software to invoke
//        this interrupt/trap gate explicitly using an int instruction.
#define SETGATE(gate, istrap, sel, off, d)                \
{                                                         \
  (gate).off_15_0 = (uint) (off) & 0xffff;                \
  (gate).cs = (sel);                                      \
  (gate).args = 0;                                        \
  (gate).rsv1 = 0;                                        \
  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
  (gate).s = 0;                                           \
  (gate).dpl = (d);                                       \
  (gate).p = 1;                                           \
  (gate).off_31_16 = (uint) (off) >> 16;                  \
}
```

When interrupt occurs, the CPU go to IDT, get the respective entry according to the intno, and get the starting address of the handler function (which is `vector[i]`). But then one question is what and where is `vector[i]` defined ? It is defined in the `vector.pl` which produce `vector.s` at build time. This is actually clever way to not lay out all the vector assembly. 


```pl
print "# generated by vectors.pl - do not edit\n";
print "# handlers\n";
print ".globl alltraps\n";
for(my $i = 0; $i < 256; $i++){
    print ".globl vector$i\n";
    print "vector$i:\n";
    if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
        print "  pushl \$0\n";
    }
    print "  pushl \$$i\n";
    print "  jmp alltraps\n";
}

print "\n# vector table\n";
print ".data\n";
print ".globl vectors\n";
print "vectors:\n";
for(my $i = 0; $i < 256; $i++){
    print "  .long vector$i\n";
}

```

Something special from the script is that if the intno == 8 || 10 >= intno <= 14 || intno == 17

its vector function is:

```asm 

.globl vector14
vector14:
  pushl $14
  jmp alltraps

```
For other function:
```asm
.globl vector0
vector0:
  pushl $0
  pushl $0
  jmp alltraps
.globl vector1

```

This is because for function like page fault, Invalid TSS, the CPU will push an extra errno to the stack. But we want a consistent trapframe. Thus for other function, we just push a fake errno number.

Below is the vector array:
```asm
.data
.globl vectors
vectors:
  .long vector0
  .long vector1
  .long vector2
  ...
```

As you observe that every interrupt functions will jump to `alltrap`(defined in `trapasm.S`):

```S
#include "mmu.h"

  # vectors.S sends all traps here.
.globl alltraps
alltraps:
  # Build trap frame.
  pushl %ds
  pushl %es
  pushl %fs
  pushl %gs
  pushal
  
  # Set up data segments.
  movw $(SEG_KDATA<<3), %ax
  movw %ax, %ds
  movw %ax, %es

  # Call trap(tf), where tf=%esp
  pushl %esp
  call trap
  addl $4, %esp

  # Return falls through to trapret...
.globl trapret
trapret:
  popal
  popl %gs
  popl %fs
  popl %es
  popl %ds
  addl $0x8, %esp  # trapno and errcode
  iret
```

**Trapframe** is a special struct, it represents the snapshot of CPU state before handling interrupts. We need this so that we could safely return back to the user execution when we finish handling the interrupts. The trapframe struct as follow:

```c
struct trapframe {
  // registers as pushed by pusha
  uint edi;
  uint esi;
  uint ebp;
  uint oesp;      // useless & ignored
  uint ebx;
  uint edx;
  uint ecx;
  uint eax;

  // rest of trap frame
  ushort es;
  ushort padding1;
  ushort ds;
  ushort padding2;
  uint trapno;

  // below here defined by x86 hardware
  uint err;
  uint eip;
  ushort cs;
  ushort padding3;
  uint eflags;

  // below here only when crossing rings, such as from user to kernel
  uint esp;
  ushort ss;
  ushort padding4;
};
```

So the whole procedure is : 
During interrupt: 

1. CPU push ss, esp, eflags, cs, eip, (err)
2. In vector[i]: Push err (optionally) and trap/syscall number
3. In alltraps : 
    - Push ds, es, fs, gs, and all general registers (pusha)
    - Push esp (trapframe), which we could access it in the `trap` function


**trap()**
```c
void
trap(struct trapframe *tf)
{
  if(tf->trapno == T_SYSCALL){
    if(myproc()->killed)
      exit();
    myproc()->tf = tf;
    syscall();
    if(myproc()->killed)
      exit();
    return;
  }
...
}
```

The code simply check if the current process that made the system call is killed or not; If so then just simply exit and cleans up the process. (Not proceeeding the syscall). Otherwise call the `syscall()` to perform the actual system call. Finally, it checks whether the process has been killed again before returning.

``` c
static int (*syscalls[])(void) = {
[SYS_chdir]   sys_chdir,
[SYS_close]   sys_close,
[SYS_dup]     sys_dup,
[SYS_exec]    sys_exec,
[SYS_exit]    sys_exit,
[SYS_fork]    sys_fork,
[SYS_fstat]   sys_fstat,
[SYS_getpid]  sys_getpid,
[SYS_kill]    sys_kill,
[SYS_link]    sys_link,
[SYS_mkdir]   sys_mkdir,
[SYS_mknod]   sys_mknod,
[SYS_open]    sys_open,
[SYS_pipe]    sys_pipe,
[SYS_read]    sys_read,
[SYS_sbrk]    sys_sbrk,
[SYS_sleep]   sys_sleep,
[SYS_unlink]  sys_unlink,
[SYS_wait]    sys_wait,
[SYS_write]   sys_write,
};

void
syscall(void)
{
  int num;
  
  num = cp->tf->eax;
  if(num >= 0 && num < NELEM(syscalls) && syscalls[num])
    cp->tf->eax = syscalls[num]();
  else {
    cprintf("%d %s: unknown sys call %d\n", 
        cp->pid, cp->name, num);
    cp->tf->eax = -1;
  }
}

```

Here according to the trapno, we invoke the respective syscall defined in sysproc.c and proc.c. When the syscall returns, we need to 1. Pop back the segment registers. Pop back to resume CPU state, clear the trapno and errcode and then return from interrupt

``` asm
# Return falls through to trapret...
.globl trapret
trapret:
  popal
  popl %gs
  popl %fs
  popl %es
  popl %ds
  addl $0x8, %esp  # trapno and errcode
  iret

```


### Interrupt procedure  
```css

Interrupt n
   │
   ▼
IDT[n] → vectors[n] (points to vectorn in vectors.S)
   │
   ▼
vector[n]: push error code, push n → jmp alltraps
   │
   ▼
alltraps (trapasm.S) → builds trapframe → calls trap(tf)
   │
   ▼
trap() in trap.c → switch-case dispatch (T_SYSCALL, IRQ_TIMER, etc) → call syscall()
   │
   ▼
syscall() in syscall.c → Base on the trapno, call the respective syscall (i.e. sys_fork(), sys_wait()) defined in proc.c and sysproc.c
   │
   ▼
alltraps (trapasm.S)→ Clean up stack and return from interrupt
   │
   ▼
```